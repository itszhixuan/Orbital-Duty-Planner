{"ast":null,"code":"const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\n\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\n\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n\n};\n\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nconst unwrap = value => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","map":{"version":3,"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","catch","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","storeNames","args","call","unwrap","sort","includes","apply","transformCachableValue","Proxy","IDBRequest","newValue","a","i","r","u","w"],"sources":["C:/Users/leezh/Documents/Coding/Orbital Test/Orbital-Duty-Planner/node_modules/@firebase/app/node_modules/idb/build/wrap-idb-value.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\r\n\r\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    set(target, prop, value) {\r\n        target[prop] = value;\r\n        return true;\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction replaceTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\r\n\r\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}